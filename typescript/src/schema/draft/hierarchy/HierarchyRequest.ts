import { z } from "zod";

export const HierarchyRequest = z.object({ "locate": z.object({ "file_path": z.string(), "scope": z.union([z.object({ "line": z.union([z.number().int(), z.array(z.any()).min(2).max(2)]) }).describe("Scope by line range"), z.object({ "symbol_path": z.array(z.string()) }).describe("Scope by symbol, also serves as declaration locator when find is omitted"), z.null()]).default(null), "find": z.union([z.string(), z.null()]).default(null), "marker": z.string().default("<HERE>") }).describe("Two-stage location: scope â†’ find.\n\nResolution rules:\n    1. SymbolScope without find: symbol declaration position (for references, rename)\n    2. With find containing marker: marker position\n    3. With find only: start of matched text\n    4. No scope + find: search entire file\n\nExamples:\n    # Symbol declaration\n    Locate(file_path=\"foo.py\", scope=SymbolScope(symbol_path=[\"MyClass\"]))\n\n    # Completion trigger point\n    Locate(file_path=\"foo.py\", find=\"self.<HERE>\")\n\n    # When source contains \"<HERE>\", use custom marker\n    Locate(file_path=\"foo.py\", find=\"x = <|>value\", marker=\"<|>\")\n\n    # Specific location in function\n    Locate(\n        file_path=\"foo.py\",\n        scope=SymbolScope(symbol_path=[\"process\"]),\n        find=\"return <HERE>result\"\n    )"), "hierarchy_type": z.enum(["call","type"]), "direction": z.enum(["incoming","outgoing","both"]).default("both"), "depth": z.number().int().default(2), "include_external": z.boolean().default(false) }).describe("Traces hierarchical relationships in a directed graph of symbols.\n\nThis API traces two types of hierarchies:\n- \"call\": Function/method call relationships (who calls whom)\n- \"type\": Class/interface inheritance relationships (parent-child)\n\nUsage Examples:\n\n1. Find who calls a function (incoming calls):\n   HierarchyRequest(\n       hierarchy_type=\"call\",\n       locate=Locate(file_path=\"src/main.py\", scope=LineScope(line=10), find=\"process_data\"),\n       direction=\"incoming\",\n       depth=2\n   )\n\n2. Find what a function calls (outgoing calls):\n   HierarchyRequest(\n       hierarchy_type=\"call\",\n       locate=Locate(file_path=\"src/main.py\", scope=LineScope(line=10), find=\"process_data\"),\n       direction=\"outgoing\",\n       depth=2\n   )\n\n3. Find parent classes (incoming in type hierarchy):\n   HierarchyRequest(\n       hierarchy_type=\"type\",\n       locate=Locate(file_path=\"src/models.py\", scope=LineScope(line=5), find=\"UserModel\"),\n       direction=\"incoming\",\n       depth=2\n   )\n\n4. Find child classes (outgoing in type hierarchy):\n   HierarchyRequest(\n       hierarchy_type=\"type\",\n       locate=Locate(file_path=\"src/models.py\", scope=LineScope(line=5), find=\"BaseModel\"),\n       direction=\"outgoing\",\n       depth=2\n   )\n\nDirection is in graph terms (not hierarchy-specific):\n- \"incoming\": predecessors (callers for calls, parent classes for types)\n- \"outgoing\": successors (callees for calls, child classes for types)\n- \"both\": explore both directions");
