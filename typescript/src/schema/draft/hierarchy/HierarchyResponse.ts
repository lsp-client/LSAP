import { z } from "zod";

export const HierarchyResponse = z.object({ "hierarchy_type": z.enum(["call","type"]), "root": z.object({ "id": z.string(), "name": z.string(), "kind": z.string(), "file_path": z.string(), "range_start": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP."), "detail": z.union([z.string(), z.null()]).default(null) }).describe("Represents a node in a hierarchy graph.\n\nApplicable to any hierarchical relationship: function calls, type inheritance, etc."), "nodes": z.record(z.object({ "id": z.string(), "name": z.string(), "kind": z.string(), "file_path": z.string(), "range_start": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP."), "detail": z.union([z.string(), z.null()]).default(null) }).describe("Represents a node in a hierarchy graph.\n\nApplicable to any hierarchical relationship: function calls, type inheritance, etc.")), "edges_incoming": z.record(z.array(z.object({ "from_node_id": z.string(), "to_node_id": z.string(), "metadata": z.union([z.object({ "call_sites": z.array(z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP.")) }).describe("Metadata specific to call relationships"), z.object({ "relationship": z.enum(["extends","implements"]) }).describe("Metadata specific to type inheritance relationships"), z.null()]).default(null) }).describe("Represents a directed edge in the hierarchy graph.\n\nThe edge connects two nodes and may carry metadata specific to the relationship type."))), "edges_outgoing": z.record(z.array(z.object({ "from_node_id": z.string(), "to_node_id": z.string(), "metadata": z.union([z.object({ "call_sites": z.array(z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP.")) }).describe("Metadata specific to call relationships"), z.object({ "relationship": z.enum(["extends","implements"]) }).describe("Metadata specific to type inheritance relationships"), z.null()]).default(null) }).describe("Represents a directed edge in the hierarchy graph.\n\nThe edge connects two nodes and may carry metadata specific to the relationship type."))), "items_incoming": z.array(z.object({ "name": z.string(), "kind": z.string(), "file_path": z.string(), "level": z.number().int(), "detail": z.union([z.string(), z.null()]).default(null), "is_cycle": z.boolean().default(false) }).describe("Represents an item in a flattened hierarchy tree for rendering.\n\nApplicable to any hierarchical relationship.")).default([]), "items_outgoing": z.array(z.object({ "name": z.string(), "kind": z.string(), "file_path": z.string(), "level": z.number().int(), "detail": z.union([z.string(), z.null()]).default(null), "is_cycle": z.boolean().default(false) }).describe("Represents an item in a flattened hierarchy tree for rendering.\n\nApplicable to any hierarchical relationship.")).default([]), "direction": z.string(), "depth": z.number().int() }).describe("Response containing the hierarchy graph and flattened tree.\n\nThe response uses generic graph terminology:\n- edges_incoming: edges pointing to nodes (callers or supertypes)\n- edges_outgoing: edges pointing from nodes (callees or subtypes)\n- items_incoming: flattened list of incoming relationships\n- items_outgoing: flattened list of outgoing relationships");

export const HierarchyResponseTemplates = {
  "markdown": "\n# {{ root.name }} Hierarchy ({{ hierarchy_type }}, depth: {{ depth }})\n\n{% if direction == \"incoming\" or direction == \"both\" %}\n## Incoming\n\n{% for item in items_incoming %}\n{% for i in (1..item.level) %}#{% endfor %}## {{ item.name }}\n- Kind: `{{ item.kind }}`\n- File: `{{ item.file_path }}`\n{%- if item.detail != nil %}\n- Detail: {{ item.detail }}\n{%- endif %}\n{%- if item.is_cycle %}\n- ⚠️ Cycle detected\n{%- endif %}\n\n{% endfor %}\n{% endif %}\n\n{% if direction == \"outgoing\" or direction == \"both\" %}\n## Outgoing\n\n{% for item in items_outgoing %}\n{% for i in (1..item.level) %}#{% endfor %}## {{ item.name }}\n- Kind: `{{ item.kind }}`\n- File: `{{ item.file_path }}`\n{%- if item.detail != nil %}\n- Detail: {{ item.detail }}\n{%- endif %}\n{%- if item.is_cycle %}\n- ⚠️ Cycle detected\n{%- endif %}\n\n{% endfor %}\n{% endif %}\n"
} as const;
