import { z } from "zod";

export const CompletionRequest = z.object({ "max_items": z.union([z.number().int(), z.null()]).default(15), "start_index": z.number().int().default(0), "pagination_id": z.union([z.string(), z.null()]).default(null), "locate": z.object({ "file_path": z.string(), "scope": z.union([z.object({ "line": z.union([z.number().int(), z.array(z.any()).min(2).max(2)]) }).describe("Scope by line range"), z.object({ "symbol_path": z.array(z.string()) }).describe("Scope by symbol, also serves as declaration locator when find is omitted"), z.null()]).default(null), "find": z.union([z.string(), z.null()]).default(null), "marker": z.string().default("<HERE>") }).describe("Two-stage location: scope â†’ find.\n\nResolution rules:\n    1. SymbolScope without find: symbol declaration position (for references, rename)\n    2. With find containing marker: marker position\n    3. With find only: start of matched text\n    4. No scope + find: search entire file\n\nExamples:\n    # Symbol declaration\n    Locate(file_path=\"foo.py\", scope=SymbolScope(symbol_path=[\"MyClass\"]))\n\n    # Completion trigger point\n    Locate(file_path=\"foo.py\", find=\"self.<HERE>\")\n\n    # When source contains \"<HERE>\", use custom marker\n    Locate(file_path=\"foo.py\", find=\"x = <|>value\", marker=\"<|>\")\n\n    # Specific location in function\n    Locate(\n        file_path=\"foo.py\",\n        scope=SymbolScope(symbol_path=[\"process\"]),\n        find=\"return <HERE>result\"\n    )") }).describe("Gets code completion suggestions at a specific position.\n\nUse this when you need to discover available attributes, methods, or variables\nat a cursor position to help write or edit code.");
