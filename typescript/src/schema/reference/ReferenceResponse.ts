import { z } from "zod";

export const ReferenceResponse = z.object({ "start_index": z.number().int(), "max_items": z.union([z.number().int(), z.null()]).default(null), "total": z.union([z.number().int(), z.null()]).default(null), "has_more": z.boolean().default(false), "pagination_id": z.union([z.string(), z.null()]).default(null), "request": z.object({ "locate": z.object({ "file_path": z.string(), "scope": z.union([z.object({ "line": z.union([z.number().int(), z.array(z.any()).min(2).max(2)]) }).describe("Scope by line range"), z.object({ "symbol_path": z.array(z.string()) }).describe("Scope by symbol, also serves as declaration locator when find is omitted"), z.null()]).default(null), "find": z.union([z.string(), z.null()]).default(null), "marker": z.string().default("<HERE>") }).describe("Two-stage location: scope â†’ find.\n\nResolution rules:\n    1. SymbolScope without find: symbol declaration position (for references, rename)\n    2. With find containing marker: marker position\n    3. With find only: start of matched text\n    4. No scope + find: search entire file\n\nExamples:\n    # Symbol declaration\n    Locate(file_path=\"foo.py\", scope=SymbolScope(symbol_path=[\"MyClass\"]))\n\n    # Completion trigger point\n    Locate(file_path=\"foo.py\", find=\"self.<HERE>\")\n\n    # When source contains \"<HERE>\", use custom marker\n    Locate(file_path=\"foo.py\", find=\"x = <|>value\", marker=\"<|>\")\n\n    # Specific location in function\n    Locate(\n        file_path=\"foo.py\",\n        scope=SymbolScope(symbol_path=[\"process\"]),\n        find=\"return <HERE>result\"\n    )"), "max_items": z.union([z.number().int(), z.null()]).default(null), "start_index": z.number().int().default(0), "pagination_id": z.union([z.string(), z.null()]).default(null), "mode": z.enum(["references","implementations"]).default("references"), "context_lines": z.number().int().default(2) }).describe("Finds all references (usages) or concrete implementations of a symbol.\n\nUse this to see where a function, class, or variable is used across the codebase,\nor to find how an interface is implemented in subclasses."), "items": z.array(z.object({ "location": z.object({ "file_path": z.string(), "range": z.object({ "start": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP."), "end": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP.") }) }), "code": z.string().describe("Surrounding code snippet"), "symbol": z.union([z.object({ "file_path": z.string(), "name": z.string(), "path": z.array(z.string()), "kind": z.enum(["file","module","namespace","package","class","method","property","field","constructor","enum","interface","function","variable","constant","string","number","boolean","array","object","key","null","enumMember","struct","event","operator","typeParameter"]), "range": z.union([z.object({ "start": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP."), "end": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP.") }), z.null()]).default(null), "detail": z.union([z.string(), z.null()]).default(null), "hover": z.union([z.string(), z.null()]).default(null) }), z.null()]).describe("The symbol containing this reference").default(null) })) });

export const ReferenceResponseTemplates = {
  "markdown": "\n# {{ request.mode | capitalize }} Found\n\n{% if total != nil -%}\nTotal {{ request.mode }}: {{ total }} | Showing: {{ items.size }}{% if max_items != nil %} (Offset: {{ start_index }}, Limit: {{ max_items }}){% endif %}\n{%- endif %}\n\n{% if items.size == 0 -%}\nNo {{ request.mode }} found.\n{%- else -%}\n{%- for item in items -%}\n### {{ item.location.file_path }}:{{ item.location.range.start.line }}\n{%- if item.symbol != nil %}\nIn `{{ item.symbol.path | join: \".\" }}` (`{{ item.symbol.kind }}`)\n{%- endif %}\n\n```{{ item.location.file_path.suffix | remove_first: \".\" }}\n{{ item.code }}\n```\n\n{% endfor -%}\n\n{% if has_more -%}\n---\n> [!TIP]\n> More {{ request.mode }} available.\n{%- if pagination_id != nil %}\n> Use `pagination_id=\"{{ pagination_id }}\"` to fetch the next page.\n{%- else %}\n> To see more, specify a `max_items` and use: `start_index={% assign step = max_items | default: items.size %}{{ start_index | plus: step }}`\n{%- endif %}\n{%- endif %}\n{%- endif %}\n"
} as const;
