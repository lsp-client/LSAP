import { z } from "zod";

export const DefinitionResponse = z.object({ "request": z.object({ "locate": z.object({ "file_path": z.string(), "scope": z.union([z.object({ "line": z.union([z.number().int(), z.array(z.any()).min(2).max(2)]) }).describe("Scope by line range"), z.object({ "symbol_path": z.array(z.string()) }).describe("Scope by symbol, also serves as declaration locator when find is omitted"), z.null()]).default(null), "find": z.union([z.string(), z.null()]).default(null), "marker": z.string().default("<HERE>") }).describe("Two-stage location: scope â†’ find.\n\nResolution rules:\n    1. SymbolScope without find: symbol declaration position (for references, rename)\n    2. With find containing marker: marker position\n    3. With find only: start of matched text\n    4. No scope + find: search entire file\n\nExamples:\n    # Symbol declaration\n    Locate(file_path=\"foo.py\", scope=SymbolScope(symbol_path=[\"MyClass\"]))\n\n    # Completion trigger point\n    Locate(file_path=\"foo.py\", find=\"self.<HERE>\")\n\n    # When source contains \"<HERE>\", use custom marker\n    Locate(file_path=\"foo.py\", find=\"x = <|>value\", marker=\"<|>\")\n\n    # Specific location in function\n    Locate(\n        file_path=\"foo.py\",\n        scope=SymbolScope(symbol_path=[\"process\"]),\n        find=\"return <HERE>result\"\n    )"), "mode": z.enum(["definition","declaration","type_definition"]).default("definition") }).describe("Finds the definition, declaration, or type definition of a symbol.\n\nUse this to jump to the actual source code where a symbol is defined,\nits declaration site, or the definition of its type/class."), "items": z.array(z.object({ "file_path": z.string(), "name": z.string(), "path": z.array(z.string()), "kind": z.enum(["file","module","namespace","package","class","method","property","field","constructor","enum","interface","function","variable","constant","string","number","boolean","array","object","key","null","enumMember","struct","event","operator","typeParameter"]), "range": z.union([z.object({ "start": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP."), "end": z.object({ "line": z.number().int().gte(1), "character": z.number().int().gte(1) }).describe("Represents a specific position in a file using line and character numbers.\n\nNote: Line and character are 1-based indices. 0-based indices are used in LSP, so conversion is needed when interfacing with LSP.") }), z.null()]).default(null), "code": z.union([z.string(), z.null()]).default(null) })) });

export const DefinitionResponseTemplates = {
  "markdown": "\n# {{ request.mode | replace: \"_\", \" \" | capitalize }} Result\n\n{% if items.size == 0 -%}\nNo {{ request.mode | replace: \"_\", \" \" }} found.\n{%- else -%}\n{%- for item in items -%}\n## `{{ item.file_path }}`: {{ item.path | join: \".\" }} (`{{ item.kind }}`)\n\n{% if item.code != nil -%}\n### Content\n```{{ item.file_path.suffix | remove_first: \".\" }}\n{{ item.code }}\n```\n{%- endif %}\n\n{% endfor -%}\n{%- endif %}\n"
} as const;
